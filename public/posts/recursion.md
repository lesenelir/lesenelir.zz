---
title: '我所理解的递归'
date: '2022-12-25'
duration: '10min'
---
今年当我开始专注于编码的时候，递归这种程序设计一直是我比较头疼的问题。一来若说它简单，代码层面来看确实很简单；但若说它很难，从思维层面模拟整个代码执行过程又是一件相对而言比较困难的事情。所以很多人包括我在内，也很难彻底的领悟递归这种程序设计。

今天写这篇博文不是说，我现在可以非常流畅的将递归运用到我的程序设计当中，而是分享一些我所理解的递归。

我将分五个部分来介绍递归：函数调用栈、递归调用栈、递归树、Leetcode递归问题、前端递归问题。

### 函数调用栈

首先阅读以下代码块：

```js
function A() {
  console.log('A Start')
  B()
  console.log('A End')
}

function B() {
  console.log('B Start')
  C()
  console.log('B End')
}
function C() {
  console.log('C Start')
  // do something...
  console.log('C End')
}

function main() {
  A()
}

main()

// ------------------------------------
// 最终输出结果如下：
A Start
B Start
C Start
C End
B End
A End
```

要理解递归，首先得从函数调用栈开始说起。如上代码块，当一个函数调用后，就会将函数压入函数调用栈中。

例如，main函数执行，则将main函数压入函数调用栈中；main函数执行函数A，则此时把A函数压入函数调用栈，并执行A函数的内容，即打印'A Start'并执行函数B；此时把由于调用了新的函数B，需要把函数B压入函数调用栈中，并执行B函数的内容，即打印'B Start'并执行函数C；此时由于调用了新的函数C，需要把函数C压入函数调用栈中，并执行函数C的内容，打印'C Start' 和 'C End'。截止至当前描述，控制台打印的内容依次为：“A Start、 B Start、C Start、C End”。

由此引出一个新的问题，接下去程序将如何执行？

在Javascript中，如果一个函数没有return语句，当整个函数执行完后，默认返回的是undefined，但返回哪里去呢？答案是：**哪里调用返回哪里去，并且当函数执行完后，函数调用栈执行pop操作，将该函数移除函数调用栈。**

>Q：对于`return 0` 和 `return` 有什么区别呢？
>
>A：`return 0`代表结束函数调用+函数的返回值是0，如果该函数调用语句是一个赋值语句，则变量值为0；`return`仅仅代表结束函数调用（函数的`return`相当于函数调用栈的pop操作）

---

### 递归调用栈

当我们弄清楚函数调用栈这个概念后，我们引出第二个概念：递归调用栈。首先我们提出：什么是递归？一个最常见也是最简单的概念是说，递归是函数自己调用自己的过程。

由此我们可以得到两个论点：

- 由函数调用栈可以得出：函数的每一次调用都会将函数存入函数调用栈；函数调用结束pop

- 递归：函数自己调用自己的过程

由这两个论点我们可以推出一条推论：

>递归是把自身函数存入函数调用栈中，且当自身函数调用结束后，将自身的函数pop出函数调用栈。

由于递归的整个过程中，函数调用栈都是存放的同一个但不同参数的函数，所以我们也把递归函数调用栈也称之为“递归调用栈”。

下面我结合一个具体案例来解释递归。思考一个正向和逆向打印数组元素的案例：

```js
const arr = [0, 1, 2],
			len = arr.length

// 正向打印数组元素
for (let i = 0; i < len; i++) {
	console.log('arr[', i, '] = ', arr[i])	
}

// 逆向打印数组元素
for (let i = len - 1; i >= 0; i--) {
  console.log('arr[', i, '] = ', arr[i])
}
```

上面是一段极其简单的遍历数组元素的代码，但如果要用递归该如何做到呢？

递归代码如下：

```js
const arr = [0, 1, 2],
      len = arr.length

function traversal(arr, i) {
  // 递归出口
  if (i === len) {
    return
  }
  
  console.log('arr[', i, '] = ', arr[i])  // 正序打印
  traversal(arr, i + 1)
  console.log('arr[', i, '] = ', arr[i])  // 逆序打印
}

traversal(arr, 0)
// ------------------------------------
// 最终输出结果如下：
arr[ 0 ] =  0
arr[ 1 ] =  1
arr[ 2 ] =  2
arr[ 2 ] =  2 // 从这一步开始“归操作”
arr[ 1 ] =  1
arr[ 0 ] =  0
```

我将带你完整的讲述整个递归的过程：

首先Javascript进行预编译，变量声明和函数声明后，执行`traversal(arr, 0)`这条语句，进入traversal函数，并将该函数`traversal(arr, 0)`压入递归调用栈中；

进入函数此时`i === 0 && i !== len`跳过if语句块，打印出：arr[0] = 0，并执行`traversal(arr, 1)`语句，进入traversal函数，并将该函数`traversal(arr, 1`压入递归调用栈中；

进入函数此时`i === 1 && i !== len`跳过if语句块，打印出：arr[1] = 1，并执行`traversal(arr, 2)`语句，进入traversal函数，并将该函数`traversal(arr, 2)`压入递归调用栈中；

进入函数此时`i === 2 && i !== len`跳过if语句块，打印出：arr[2] = 2，并执行`traversal(arr, 3)`语句，进入traversal函数，并将该函数`traversal(arr, 3)`压入递归调用栈中；

进入函数此时`i === 3 && i === len`，此时i的值和len的值相等进入if语句块，但此时if语句块中只有一句return，这是什么意思呢？答案已在“函数调用栈”中给出：**return就是结束当前调用的函数，将当前函数pop出递归调用栈。**具体来说此处将`traversal(arr, 3)`语句弹出递归调用栈，并返回至上一层函数`traversal(arr, 2)`调用位置处继续执行`traversal(arr, 2)`函数，打印出：arr[2] = 2；

此时函数`traversal(arr, 2)`全部执行完后将该函数从递归栈中弹出，并返回至上一层函数`traversal(arr, 1)`调用位置处继续执行`traversal(arr, 1)`函数，打印出：arr[1] = 1；

此时函数`traversal(arr, 1)`全部执行完后将该函数从递归栈中弹出，并返回至上一层函数`traversal(arr, 0)`调用位置处继续执行`traversal(arr, 0)`函数，打印出：arr[0] = 0；

至此整个递归函数全部执行完。

同时我们又引出一个新的问题，为什么正序打印元素是在递归语句之前，逆序打印元素是在递归语句之后？递归语句的前后语句又有什么意义？

对于这两个问题，我自己总结出一个准则：

- 递归语句之前是执行当前调用函数需要执行的语句，是一个“递”的过程
- 递归语句之后是执行下一层调用函数执行完后需要执行的语句，是一个“归”的过程

所以很多地方也可以看到对于递归的描述为：

>“递”过程是进入节点；“归”过程是离开节点（节点的概念将在递归树中讲解）








